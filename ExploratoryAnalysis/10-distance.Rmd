---
title: "10-distance"
output: html_document
date: "2025-10-13"
---

# load packages
```{r}
packages <-
  c(
    "stringr",
    "sf",
    "tidyverse",
    "viridis",
    "glue",
    "patchwork",
    "tidyr",
    "dplyr",
    "knitr",
    "kableExtra",
    "vtable",
    "stargazer",
    "ggplot2",
    "haven",
    "estimatr",
    "geosphere",
    "lmtest",
    "sandwich",
    "margins"
  )

pacman::p_load(
  packages,
  character.only = TRUE
)
```

# load data
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

hh_survey <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdSurvey",
      "DataSets",
      "Final",
      "hh-survey.rds"
    )
  ) #%>%
 # dplyr::filter(survey == "Household Survey")

hh_survey_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdSurvey",
      "DataSets",
      "Spatial",
      "hh-survey-constructed.rds"
    )
  ) #%>%
  #dplyr::filter(survey == "Household Survey")

hh_census <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdCensus",
      "DataSets",
      "Final",
      "hh-census.rds"
    )
  ) %>%
 # st_drop_geometry() %>%
  mutate(
    response = response * 100,
    served = (wp_intervention_type != "Non-program") * 100
  )

hh_census_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdCensus",
      "DataSets",
      "Spatial",
      "hh-census-constructed.rds"
    )
  ) %>%
 # st_drop_geometry() %>%
  mutate(
    response = response * 100,
    served = (wp_intervention_type != "Non-program") * 100
  )

wp_census_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "WaterPointCensus",
      "DataSets",
      "Spatial",
      "wp-gps-constructed.rds"
    )
  )

wp_census <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "WaterPointCensus",
      "DataSets",
      "Final",
      "wp-census.rds"
    )
  )
```

# add geometry to hh census and wp census
```{r}
# to hh census
hh_census_geom <- hh_census %>%
  left_join(hh_census_constructed %>% select(geometry, household_id, gpsaccuracy),
            by = "household_id")

# merge with chlorine test results from hh survey
hh_census_geom <- hh_census_geom %>%
  left_join(
    hh_survey %>%
      select(household_id, disctcr, discfcr),
      by = "household_id"
  ) %>%
  mutate(
    disc_tcr_detected = as.numeric(disctcr > 0.2)
  )

# to wp census
wp_census_geom <- wp_census %>%
  mutate(wp_id = paste0("WP", wp_id)) %>%
  left_join(wp_census_constructed %>% select(geometry, wp_id), 
            # wp_gpsaccuracy = gps_accuracy),
            by = "wp_id")

wp_census_geom <- wp_census_geom %>%
  dplyr::filter(!st_is_empty(geometry))
```

# extracting household and water point longitude and latitude from geometry
```{r}
# hh census
hh_census_geom <- hh_census_geom %>%
  mutate(
    hh_lon = st_coordinates(geometry)[, 1],
    hh_lat = st_coordinates(geometry)[, 2]
  )

# wp census
wp_census_geom <- wp_census_geom %>%
  mutate(
    point_geom = st_collection_extract(geometry, type = "POINT")
  )

wp_coords <- st_coordinates(wp_census_geom$point_geom)
wp_census_geom <- wp_census_geom %>%
  mutate(
    wp_lon = wp_coords[, 1],
    wp_lat = wp_coords[, 2]
  )
```

# calculating distance to primary WP
```{r}
hh_with_primary <- hh_census_geom %>%
  left_join(
    wp_census_geom %>%
      mutate(wp_id = gsub("^WP", "", wp_id)) %>%  
      select(wp_id, primary_wp_lon = wp_lon, primary_wp_lat = wp_lat),
    by = "wp_id"
  )

hh_with_primary <- hh_with_primary %>%
  mutate(
    dist_to_primary_m = distHaversine(
      cbind(hh_lon, hh_lat),
      cbind(primary_wp_lon, primary_wp_lat)
    ))

hh_with_primary <- hh_with_primary %>%
  # dplyr::filter(wp_gpsaccuracy < 10) %>%
    dplyr::filter(gpsaccuracy < 10)
```

# generate dataset with households far from primary wp
```{r}
hh_with_primary_far <- hh_with_primary %>%
  dplyr::filter(dist_to_primary_m > 1000) %>%
  select(country, village_id, wp_id, household_id, primary_wp_lat, primary_wp_lon, dist_to_primary_m, hh_lat, hh_lon) 
  # dplyr::distinct(wp_id)

# export to csv
write.csv(hh_with_primary_far, "hh_with_primary_far.csv", row.names = FALSE)
```

# distance to nearest EA WP
```{r}
ea_water_points <- wp_census_geom %>%
  dplyr::filter(intervention_type != "Non-program") %>%
  select(wp_id, ea_wp_lon = wp_lon, ea_wp_lat = wp_lat)

hh_with_primary <- hh_with_primary %>%
  rowwise() %>%
  mutate(
    dist_to_nearest_ea_m = min(
      distHaversine(
        cbind(hh_lon, hh_lat),
        cbind(ea_water_points$ea_wp_lon, ea_water_points$ea_wp_lat)
      ),
      na.rm = TRUE
    )
  ) %>%
  ungroup() %>%
  mutate(dist_to_nearest_ea_m = ifelse(is.infinite(dist_to_nearest_ea_m), 
                                        NA_real_, 
                                        dist_to_nearest_ea_m)) %>%
  mutate(
    ea_minus_primary_m = dist_to_nearest_ea_m - dist_to_primary_m 
  )
    
```

# summary data
```{r}
hh_filtered <- hh_with_primary %>%
  mutate(
    dist_to_primary_m = as.numeric(dist_to_primary_m)
  ) %>%
# winsorize
  mutate(
    dist_to_primary_m = as.numeric(dist_to_primary_m),
    dist_to_primary_m = case_when(
      dist_to_primary_m < quantile(dist_to_primary_m, 0.05, na.rm = TRUE) ~ 
        quantile(dist_to_primary_m, 0.05, na.rm = TRUE),
      dist_to_primary_m > quantile(dist_to_primary_m, 0.95, na.rm = TRUE) ~ 
        quantile(dist_to_primary_m, 0.95, na.rm = TRUE),
      TRUE ~ dist_to_primary_m
    )
  )

ggplot(hh_filtered, aes(y = dist_to_primary_m)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distance to Primary Water Point",
       y = "Distance (meters)") +
  theme_minimal()
```


# summary table
```{r}
hh_filtered <- hh_filtered %>%
  mutate(
    dist_to_primary_km = dist_to_primary_m / 1000,
    dist_to_nearest_ea_km = dist_to_nearest_ea_m / 1000,
    ea_minus_primary_m = dist_to_nearest_ea_m - dist_to_primary_m,
    ea_minus_primary_km = dist_to_nearest_ea_km - dist_to_primary_km,
    ea_minus_primary_100m = (dist_to_nearest_ea_m / 100) - (dist_to_primary_m / 100)
  ) 

table <- hh_filtered %>%
  group_by(disc_tcr_detected) %>%
  dplyr::filter(!is.na(dist_to_primary_m)) %>%
  summarize(
    mean_dist_primary = mean(dist_to_primary_m, na.rm = TRUE),
    mean_dist_ea = mean(dist_to_nearest_ea_m, na.rm = TRUE),
    mean_ea_minus_primary_km = mean(ea_minus_primary_km, na.rm = TRUE),
    n = n()
  )

print(table)
```

# regressions
controlling for distance to primary water point, distance to nearest EA water point is significantly (p<0.05) associated with lower probability of chlorination
## OLS
```{r}
# model with clustered SEs
model <- lm_robust(disc_tcr_detected ~ dist_to_nearest_ea_km + dist_to_primary_km, 
                   data = hh_filtered,
                   clusters = village_id,
                   se_type = "stata")

# run a regular lm (just for stargazer to recognize the object)
model_lm <- lm(disc_tcr_detected ~ dist_to_nearest_ea_km + dist_to_primary_km, 
               data = hh_filtered)

stargazer(model_lm,
          type = "text",  # change to "latex" or "html" as needed
          se = list(model$std.error),
          title = "Regression Results",
          dep.var.labels = "Disc TCR Detected",
          covariate.labels = c("Distance to Nearest EA (km)", 
                               "Distance to Primary WP (km)"),
          notes = c("Standard errors clustered at village level in parentheses.",
                    "*** p<0.01, ** p<0.05, * p<0.1"),
          notes.align = "l",
          omit.stat = c("f", "ser"))
```

## logit
A 100m increase in the distance differential is associated with approximately a 2.8 percentage point decrease in chlorination detection. This effect size is substantively relevant given that the average distance differential among households whose primary water point is not an EA water point is 74.6 meters. This suggests that even typical variations in relative distance are associated with meaningful changes in chlorination rates.
```{r}
# logit model with clustered standard errors
# model_logit <- glm(disc_tcr_detected ~ dist_to_nearest_ea_km + dist_to_primary_km + hh_under5yn + wp_secweek + dsw + ilc, 
# model_logit <- glm(disc_tcr_detected ~ dist_to_nearest_ea_km + dist_to_primary_km, 
model_logit <- glm(disc_tcr_detected ~ ea_minus_primary_100m + hh_under5yn + wp_secweek + dsw + ilc, 
                   data = hh_filtered,
                   family = binomial(link = "logit"))

coeftest(model_logit, vcov = vcovCL(model_logit, cluster = hh_filtered$village_id))

# get the clustered standard errors
clustered_se <- sqrt(diag(vcovCL(model_logit, cluster = hh_filtered$village_id)))

# create the table
stargazer(model_logit,
          type = "text",  # change to "latex" or "html" as needed
          se = list(clustered_se),
          title = "Logit Regression Results",
          dep.var.labels = "Disc TCR Detected",
          notes = c("Standard errors clustered at village level in parentheses.",
                    "*** p<0.01, ** p<0.05, * p<0.1"),
          notes.align = "l",
          omit.stat = c("aic", "ll"))

# calculate average marginal effects (AMEs)
library(margins)
ames <- margins(model_logit, vcov = vcovCL(model_logit, cluster = hh_filtered$village_id))
summary(ames)
```

## context for average effects: distribution of ea_minus_primary_m
```{r}
# hh_filtered_diff <- hh_filtered %>%
#   dplyr::filter(dist_to_primary_m != dist_to_nearest_ea_m)

# calculate mean 
mean_diff <- hh_filtered %>%
  summarise(mean_val = mean(ea_minus_primary_m, na.rm = TRUE)) %>%
  pull(mean_val)

# histogram with mean line
hh_filtered %>%
  dplyr::filter(ea_minus_primary_m != 0) %>%
  ggplot(aes(x = ea_minus_primary_m)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  geom_vline(xintercept = mean_diff, linetype = "dashed", color = "red", size = 1) +
  annotate("text", x = mean_diff, y = Inf, 
           label = paste0("Mean = ", round(mean_diff, 1), "m"), 
           vjust = 2, hjust = -0.1, color = "red") +
  labs(
    title = "Distribution of Distance Differential Between Nearest EA water point \nand primary water point",
    x = "EA water point distance - Primary water point distance (meters)",
    y = "Count"
  ) +
  theme_minimal()
```  

## context for average effects: SD of chlorination
```{r}
# for binary outcome
mean_chlorination <- mean(hh_filtered$disc_tcr_detected, na.rm = TRUE)
sd_chlorination <- sqrt(mean_chlorination * (1 - mean_chlorination))

sd_chlorination

effect_per_100m <- 2.8
effect_in_sds <- (effect_per_100m / 100) / sd_chlorination

cat("Effect per 100m:", round(effect_in_sds, 3), "standard deviations")
```
