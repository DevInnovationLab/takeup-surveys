---
title: "10-distance"
output: html_document
date: "2025-10-13"
---

```{r}
packages <-
  c(
    "stringr",
    "sf",
    "tidyverse",
    "viridis",
    "glue",
    "patchwork",
    "tidyr",
    "dplyr",
    "knitr",
    "kableExtra",
    "vtable",
    "stargazer",
    "ggplot2",
    "haven",
    "estimatr",
    "geosphere"
  )

pacman::p_load(
  packages,
  character.only = TRUE
)
```

# load data
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

hh_survey <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdSurvey",
      "DataSets",
      "Final",
      "hh-survey.rds"
    )
  ) #%>%
 # dplyr::filter(survey == "Household Survey")

hh_survey_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdSurvey",
      "DataSets",
      "Spatial",
      "hh-survey-constructed.rds"
    )
  ) #%>%
  #dplyr::filter(survey == "Household Survey")

hh_census <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdCensus",
      "DataSets",
      "Final",
      "hh-census.rds"
    )
  ) %>%
 # st_drop_geometry() %>%
  mutate(
    response = response * 100,
    served = (wp_intervention_type != "Non-program") * 100
  )

hh_census_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "HouseholdCensus",
      "DataSets",
      "Spatial",
      "hh-census-constructed.rds"
    )
  ) %>%
 # st_drop_geometry() %>%
  mutate(
    response = response * 100,
    served = (wp_intervention_type != "Non-program") * 100
  )

wp_census_constructed <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "WaterPointCensus",
      "DataSets",
      "Spatial",
      "wp-gps-constructed.rds"
    )
  )

wp_census <-
  read_rds(
    file.path(
      path_box,
      "Data",
      "WaterPointCensus",
      "DataSets",
      "Final",
      "wp-census.rds"
    )
  )
```

# add geometry to hh census and wp census
```{r}
hh_census_geom <- hh_census %>%
  left_join(hh_census_constructed %>% select(geometry, household_id, gpsaccuracy),
            by = "household_id")

# merge with chlorine test results from hh survey
hh_census_geom <- hh_census_geom %>%
  left_join(
    hh_survey %>%
      select(household_id, disctcr, discfcr),
      by = "household_id"
  ) %>%
  mutate(
    disc_tcr_detected = as.numeric(disctcr > 0.2)
  )

wp_census_geom <- wp_census %>%
  mutate(wp_id = paste0("WP", wp_id)) %>%
  left_join(wp_census_constructed %>% select(geometry, wp_id), 
            # wp_gpsaccuracy = gps_accuracy),
            by = "wp_id")

wp_census_geom <- wp_census_geom %>%
  dplyr::filter(!st_is_empty(geometry))
```

# extracting household and water point longitude and latitude from geometry
```{r}
hh_census_geom <- hh_census_geom %>%
  mutate(
    hh_lon = st_coordinates(geometry)[, 1],
    hh_lat = st_coordinates(geometry)[, 2]
  )

wp_census_geom <- wp_census_geom %>%
  mutate(
    point_geom = st_collection_extract(geometry, type = "POINT")
  )

wp_coords <- st_coordinates(wp_census_geom$point_geom)
wp_census_geom <- wp_census_geom %>%
  mutate(
    wp_lon = wp_coords[, 1],
    wp_lat = wp_coords[, 2]
  )
```

# calculating distance to primary WP
```{r}
hh_with_primary <- hh_census_geom %>%
  left_join(
    wp_census_geom %>%
      mutate(wp_id = gsub("^WP", "", wp_id)) %>%  
      select(wp_id, primary_wp_lon = wp_lon, primary_wp_lat = wp_lat), 
    # wp_gpsaccuracy),
    by = "wp_id"
  )

hh_with_primary <- hh_with_primary %>%
  mutate(
    dist_to_primary_m = distHaversine(
      cbind(hh_lon, hh_lat),
      cbind(primary_wp_lon, primary_wp_lat)
    ))

# hh_with_primary <- hh_with_primary %>%
#   dplyr::filter(wp_gpsaccuracy < 10) %>%
#   dplyr::filter(gpsaccuracy < 10)
```

# generate dataset with households far from primary wp
```{r}
hh_with_primary_far <- hh_with_primary %>%
  dplyr::filter(dist_to_primary_m > 1000) %>%
  select(country, village_id, wp_id, household_id, primary_wp_lat, primary_wp_lon, dist_to_primary_m, hh_lat, hh_lon) 
  # dplyr::distinct(wp_id)

# export to csv
write.csv(hh_with_primary_far, "hh_with_primary_far.csv", row.names = FALSE)
```

# distance to nearest EA WP
```{r}
ea_water_points <- wp_census_geom %>%
  dplyr::filter(intervention_type != "Non-program") %>%
  select(wp_id, ea_wp_lon = wp_lon, ea_wp_lat = wp_lat)

hh_with_primary <- hh_with_primary %>%
  rowwise() %>%
  mutate(
    dist_to_nearest_ea_m = min(
      distHaversine(
        cbind(hh_lon, hh_lat),
        cbind(ea_water_points$ea_wp_lon, ea_water_points$ea_wp_lat)
      ),
      na.rm = TRUE
    )
  ) %>%
  ungroup() %>%
  mutate(dist_to_nearest_ea_m = ifelse(is.infinite(dist_to_nearest_ea_m), 
                                        NA_real_, 
                                        dist_to_nearest_ea_m)) %>%
  mutate(
    ea_minus_primary_m = dist_to_nearest_ea_m - dist_to_primary_m 
  )
    
```

# summary data
```{r}
hh_filtered <- hh_with_primary %>%
  mutate(
    dist_to_primary_m = as.numeric(dist_to_primary_m)
  ) %>%
  dplyr::filter(dist_to_primary_m < 10000 & dist_to_primary_m > 0)

ggplot(hh_filtered, aes(y = dist_to_primary_m)) +
  geom_boxplot(fill = "lightblue") +
  labs(title = "Distance to Primary Water Point",
       y = "Distance (meters)") +
  theme_minimal()
```

# export to dta
```{r}
library(haven)
library(sf)

hh_without_geom <- st_drop_geometry(hh_with_primary)

write_dta(hh_without_geom, "hh_with_primary.dta")
```

# summary table

```{r}
table <- hh_filtered %>%
  mutate(
    dist_to_primary_km = dist_to_primary_m / 1000,
    dist_to_nearest_ea_km = dist_to_nearest_ea_m / 1000,
    ea_minus_nearest_km = dist_to_nearest_ea_km - dist_to_primary_km
  ) %>%
  group_by(disc_tcr_detected) %>%
  dplyr::filter(!is.na(dist_to_primary_m)) %>%
  summarize(
    mean_dist_primary = mean(dist_to_primary_m, na.rm = TRUE),
    mean_dist_ea = mean(dist_to_nearest_ea_m, na.rm = TRUE),
    mean_diff_km = mean(ea_minus_nearest_km, na.rm = TRUE),
    n = n()
  )

print(table)
```

```{r}
hh_with_primary_reg <- hh_with_primary %>%
  dplyr::filter(!is.na(dist_to_primary_m)) %>%
  mutate(
    dist_to_primary_km = dist_to_primary_m * 1000,
    dist_to_nearest_ea_km = dist_to_nearest_ea_m * 1000,
    ea_minus_nearest_km = dist_to_nearest_ea_km - dist_to_primary_km
  )

model <- lm_robust(disc_tcr_detected ~ ea_minus_nearest_km, 
                   data = hh_with_primary_reg,
                   clusters = village_id,
                   se_type = "stata")

clustered_se <- model$std.error

# model_lm <- lm(disctcr ~ dist_to_primary_m + dist_to_nearest_ea_m, data = hh_with_primary_reg)

model_lm <- lm(disc_tcr_detected ~ ea_minus_nearest_km, data = hh_with_primary_reg)

stargazer(model_lm,  
          type = "text",
          se = list(clustered_se),  #  use the clustered SEs from lm_robust
          digits = 3,
          star.cutoffs = c(0.05, 0.01, 0.001),
          notes = "Clustered standard errors (by village) in parentheses",
          notes.append = FALSE)
```

